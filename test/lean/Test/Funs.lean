-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [test]: function definitions
import Base
import Test.Types
open Primitives

namespace test

/- [test::arithmetics::{test::arithmetics::BigInt<N>}::default]: forward function
   Source: 'src/arithmetics.rs', lines 16:4-16:24 -/
def arithmetics.BigInt.default (N : Usize) : Result (arithmetics.BigInt N) :=
  let a := Array.repeat U64 N 0#u64
  Result.ret { num := a }

/- Trait implementation: [test::arithmetics::{test::arithmetics::BigInt<N>}]
   Source: 'src/arithmetics.rs', lines 15:0-15:42 -/
def core.default.DefaulttestarithmeticsBigIntNInst (N : Usize) :
  core.default.Default (arithmetics.BigInt N) := {
  default := arithmetics.BigInt.default N
}

/- [test::arithmetics::adc_for_add_with_carry]: forward function
   Source: 'src/arithmetics.rs', lines 33:0-33:67 -/
def arithmetics.adc_for_add_with_carry
  (a : U64) (b : U64) (carry : U8) : Result U8 :=
  do
    let i ← Scalar.cast .U128 a
    let i0 ← Scalar.cast .U128 b
    let i1 ← i + i0
    let i2 ← Scalar.cast .U128 carry
    let tmp ← i1 + i2
    let _ ← Scalar.cast .U64 tmp
    let i3 ← 1024#u128 * 1024#u128
    let i4 ← i3 * 1024#u128
    let i5 ← i4 * 1024#u128
    let i6 ← i5 * 1024#u128
    let i7 ← i6 * 1024#u128
    let _ ← i7 * 16#u128
    let i8 ← tmp >>> 64#i32
    Scalar.cast .U8 i8

/- [test::arithmetics::adc_for_add_with_carry]: backward function 0
   Source: 'src/arithmetics.rs', lines 33:0-33:67 -/
def arithmetics.adc_for_add_with_carry_back
  (a : U64) (b : U64) (carry : U8) : Result U64 :=
  do
    let i ← Scalar.cast .U128 a
    let i0 ← Scalar.cast .U128 b
    let i1 ← i + i0
    let i2 ← Scalar.cast .U128 carry
    let tmp ← i1 + i2
    let a0 ← Scalar.cast .U64 tmp
    let i3 ← 1024#u128 * 1024#u128
    let i4 ← i3 * 1024#u128
    let i5 ← i4 * 1024#u128
    let i6 ← i5 * 1024#u128
    let i7 ← i6 * 1024#u128
    let _ ← i7 * 16#u128
    let i8 ← tmp >>> 64#i32
    let _ ← Scalar.cast .U8 i8
    Result.ret a0

/- [test::arithmetics::{test::arithmetics::BigInt<N>#1}::add_with_carry]: forward function
   Source: 'src/arithmetics.rs', lines 82:4-82:54 -/
def arithmetics.BigInt.add_with_carry
  (N : Usize) (self : arithmetics.BigInt N) (other : arithmetics.BigInt N) :
  Result Bool
  :=
  if N >= 1#usize
  then
    do
      let i ← Array.index_usize U64 N self.num 0#usize
      let i0 ← Array.index_usize U64 N other.num 0#usize
      let carry ← arithmetics.adc_for_add_with_carry i i0 0#u8
      Result.ret (carry != 0#u8)
  else Result.ret (0#u8 != 0#u8)

/- [test::arithmetics::{test::arithmetics::BigInt<N>#1}::add_with_carry]: backward function 0
   Source: 'src/arithmetics.rs', lines 82:4-82:54 -/
def arithmetics.BigInt.add_with_carry_back
  (N : Usize) (self : arithmetics.BigInt N) (other : arithmetics.BigInt N) :
  Result (arithmetics.BigInt N)
  :=
  if N >= 1#usize
  then
    do
      let i ← Array.index_usize U64 N self.num 0#usize
      let i0 ← Array.index_usize U64 N other.num 0#usize
      let i1 ← arithmetics.adc_for_add_with_carry_back i i0 0#u8
      let a ← Array.update_usize U64 N self.num 0#usize i1
      Result.ret { num := a }
  else Result.ret self

/- Trait implementation: [test::arithmetics::{test::arithmetics::BigInt<N>#1}]
   Source: 'src/arithmetics.rs', lines 78:0-78:45 -/
def test.arithmetics.BigIntegertestarithmeticsBigIntNInst (N : Usize) :
  arithmetics.BigInteger (arithmetics.BigInt N) := {
  add_with_carry := arithmetics.BigInt.add_with_carry N
  add_with_carry_back := arithmetics.BigInt.add_with_carry_back N
}

end test
